* Overview

This tool makes it easy to capture the steps taken during the build process of a software project. This can be very useful for:
- Understanding build processes
- Debugging obscure build problems
- Applying static analysis and verification tools

In the first two cases, this tool gives a low-level view of exactly the set of files accessed by the build process (e.g., fully resolving all file includes and relative paths) in a way that is difficult to achieve by merely reading and understanding a build system. In a sense, it identifies the *bill of materials* for software.

In the third case, assurance tools generally require rebuilding programs in special modes or with alternative compilers (e.g., into LLVM bitcode for analysis or instrumentation). Doing so is typically labor intensive, as it requires extensive work to understand an existing build system, and more work still to modify it.  This tool provides a way to apply analysis tools in a build system agnostic way.

This tool is primarily designed to help tame the myriad build systems of the C/C++ ecosystem, but it applies to any software project with a build step.

* Usage

This tool wraps your normal build command and builds LLVM bitcode when possible.  It arranges things such that any binary artifacts produced by your build system (e.g., object files, archives, shared libraries, or binaries) have their LLVM bitcode attached to them and accessible. The workflow of this tool proceeds in two phases:
1. Building your software (using the ~generate-bitcode~ command wrapper)
2. Extracting your bitcode (using the ~extract-bitcode~ command)

There tool also supports some auxiliary commands for generating traces of builds for visualization and understanding.

An example use of the tool is shown below for a ~make~-based build:

#+BEGIN_SRC

$ build-bom generate-bitcode -- make
$ build-bom extract-bitcode /path/to/binary --output=/tmp/output.bc

#+END_SRC

In the first step, the tool acts as a wrapper around the real build system.  It runs the build system and, if it observes any compilation commands, it runs an extra build of the source file using clang to generate bitcode.  It attaches bitcode to object files, and then resumes the build.

In the next step, the tool extracts all of the accumulated bitcode.

** Bitcode Generation Options

The ~bitcode~ command has a number of options that may be useful in various contexts.

- ~--dry-run~: Replays the build without taking action
- ~--clang~: Specify the full name (or path if desired) of a clang binary to use
- ~--llvm-tool-suffix~: Specify a suffix to be appended to all LLVM command line tool names (e.g., ~llvm-link~); this is useful if LLVM commands are versioned on your system

* Design

The tool uses low-level operating system services to observe builds and record their actions.  On Linux, it uses ~ptrace~ to observe every system call.  When a source compilation command is observed, the tool generates the corresponding bitcode file using clang.  It attaches the bitcode file to the object file, allowing bitcode to be accumulated as a side effect of the build.  At every stage, bitcode remains attached to build artifacts to ensure it is not lost.

There are four key observations enabling this approach to bitcode collection:
1. Whenever we see the original build system compile a C/C++ file, we know we need to make the corresponding bitcode file
2. We can attach arbitrary extra data (e.g., bitcode) to object files in extra ELF sections
3. ELF sections containing data without special meaning are concatenated by the linker
4. Standard tar files can be concatenated to produce a valid tar file that is the union of their contents

We wrap our generated bitcode in singleton tar files and allow the linker to accumulate them for us. When we want to collect aggregated bitcode for executable artifacts, we simply extract the tar file from their special LLVM bitcode ELF sections, extract the collected bitcode, and link it together with ~llvm-link~.

This tool is also able to record all relevant system calls into a log.  The tracing is designed to capture all of the information necessary to replay a build.  It currently doesn't capture everything (especially file move and directory operations), but will be extended as-needed.  Beyond system calls, it also captures the environment and working directory of each executed command.

The tool currently supports Linux, but is designed so that it will be modular enough to have separate tracing implementations for MacOS and Windows, while sharing the rest of the code.

** Related Tools

Earlier tools in this space include

- [[https://github.com/travitch/whole-program-llvm][wllvm]]
- [[https://github.com/SRI-CSL/gllvm][gllvm]]

These tools act as drop-in replacements that pretend to be your normal compiler and linker, but run additional commands to also compile the program to LLVM bitcode.  These tools are very effective, but can require significant understanding and re-engineering of build systems to integrate.  The ~build-bom~ tool is designed to support build system analysis without any modifications to the existing build system (and ideally without ever even looking at it).

** Caveats

It is not possible to take advantage of parallel builds while using this tool, as all system calls in the entire build tree are serialized through a single tracing process.

* Full Example

Here is a full example on a real codebase:

#+BEGIN_SRC sh
  wget https://ftp.gnu.org/gnu/tar/tar-1.32.tar.gz
  tar xf tar-1.32.tar.gz
  cd tar-1.32
  ./configure
  # Run the build under the bitcode generator
  build-bom generate-bitcode -- make
  # Use a suffix of on LLVM tools because they are version-suffixed on Ubuntu
  build-bom extract-bitcode src/tar --output=../tar.bc --llvm-tool-suffix=-9
#+END_SRC

* Roadmap

- Serious polish required
- Build step dependency analysis for in-order replay
- Add more thorough support for Linux system calls
  - Add a 32 bit x86 syscall table
  - Add ARM syscall tables
  - Explore automated processing of system call argument lists
- Additional tools
  - Dependency graph analyzer and visualizer
  - A command to list all targets (or all library targets or all executable targets)
  - A command to rebuild a target binary with libfuzzer, Address Sanitizer, or Thread Sanitizer
  - Add a command to randomly test for potential missing dependencies in build systems
- Automated granular filename tracking (to precisely model renames)
- Fix parallel builds
- Full handling of environment variables
- Additional normalization policies
  - Ignore trivial dependencies like ld.so
  - Add ability to ignore dynamically loaded library dependencies
- Easier scripting
- MacOS backend based on Dtrace
- Windows backend
